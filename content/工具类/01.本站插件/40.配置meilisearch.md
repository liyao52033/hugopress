---
date: 2025-09-06 16:44:03
title: 配置meilisearch
author:
  name: liyao
  link: https://xiaoying.org.cn
url: /pages/09b133
description: >-
  本文系统讲解了meilisearch的配置流程，包括Docker部署、权限Key创建、Nginx域名配置、数据索引建立及前端Vue组件开发。通过这些步骤，可以搭建一个安全、高效且用户友好的搜索服务。
weight: 90
categories:
  - 工具类
  - 本站插件
type: docs
tags:
  - vitepress
---


## _1、服务端配置

### _1.1、部署

官方对于部署的介绍非常详细，各种方案都提供了，我这里选择使用 docker 来进行部署。

添加服务启动脚本`start.sh`到`/tmp/scraper`目录

```sh
docker run -itd --name meilisearch -p 7700:7700 --restart=always \
  -e MEILI_ENV="production" -e MEILI_NO_ANALYTICS=true \
  -e MEILI_MASTER_KEY="自定义一个不少于16字节的秘钥" \
  -v $(pwd)/meili_data:/meili_data \
  getmeili/meilisearch
```

自建的时候，需要将环境变量声明为生产，并且必须指定 master-key，否则将会提示无法使用。

然后运行该脚本，服务启动，通过监听日志，查看服务状态是否正常。

也可以请求服务的健康接口进行验证：

```sh
$ curl -s http://localhost:7700/health | jq
{
  "status": "available"
}
```

注意，生产模式下，只有这一个接口是不需要秘钥认证即可访问的，其他接口访问的时候都需要带上秘钥。

### _1.2、创建搜索的key

上边有了一个 master-key 用于爬虫抓取使用，还需要创建一个只有搜索权限的 key，可通过如下命令进行创建`search.sh`到
`/tmp/scraper`目录

```sh
curl \
  -X POST 'http://localhost:7700/keys' \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer 你自定义的秘钥' \
  --data-binary '{
    "description": "vp.xiaoying.org.cn key",
    "actions": ["search"],
    "indexes": ["blog"],  // 第四步建立索引抓取配置中的index_uid的值需与该值保持一致
    "expiresAt": "2099-01-01T00:00:00Z"
  }'
```

创建完成之后，能看到返回内容中有一个 key 的字段，就是这个只有搜索权限的 key 了。

### _1.3、添加域名

这个根据自己的实际情况，我这里给 Nginx 添加配置文件，配置域名：

```nginx
server {
    listen 443 ssl;
    server_name vp.xiaoying.org.cn;

    ssl_certificate /etc/ssl/certs/vp.xiaoying.org.cn_bundle.crt;
    ssl_certificate_key /etc/ssl/certs/vp.xiaoying.org.cn.key;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_prefer_server_ciphers on;

    location ^~ /multi-search/ {
        proxy_set_header Host $host;
        proxy_set_header   X-Forwarded-Proto $scheme;
        proxy_set_header   X-Real-IP         $remote_addr;
        proxy_pass http://127.0.0.1:7700;
    }

}

```

这样就完成了与meilisearch一样的服务端配置信息：

- 服务端 URL(https://vp.xiaoying.org.cn/)
- master key(第一步自定义)
- search key（第二步生成）

### _1.4、建立索引

官方提供了爬虫工具，我们只需要进行简单的配置，即可将数据索引建立起来。

关于这段配置流程，官方文档同样给了详细的说明：[抓取你的内容 (opens new window)](https://docs.meilisearch.com/learn/cookbooks/search_bar_for_docs.html#scrape-your-content)。

新建`config.json`如下

```json
{
    "index_uid": "teek",
    "sitemap_urls": ["https://vp.xiaoying.org.cn/sitemap.xml"],
    "start_urls": ["https://vp.xiaoying.org.cn/"],
    "stop_urls": [],
    "selectors": {
        "lvl0": {
            "selector": "section.has-active div h2",
            "defaultValue": "Documentation"
        },
        "lvl1": ".content h1", 
        "lvl2": ".content h2", 
        "lvl3": ".content h3", 
        "lvl4": ".content h4", 
        "lvl5": ".content h5", 
        "content": ".content p, .content li"    
    },
    "strip_chars": " .,;:#",
    "scrap_start_urls": true,
    "custom_settings": {
        "searchableAttributes": [
            "hierarchy_lvl2",
            "hierarchy_lvl3",
            "hierarchy_lvl4",
            "hierarchy_lvl5",
            "content"
        ],
        "displayedAttributes": [
            "hierarchy_lvl1",
            "hierarchy_lvl2",
            "hierarchy_lvl3",
            "hierarchy_lvl4",
            "hierarchy_lvl5",
            "content",
            "hierarchy_lvl0",
            "url",
            "anchor"
        ],
        "filterableAttributes": [
            "hierarchy_lvl2",
            "hierarchy_lvl3",
            "hierarchy_lvl4",
            "hierarchy_lvl5"
        ]
    },
}

```

`index_uid` ：为索引名称，如果服务端没有，则会自动创建，需与第二步的indexes保持一致。

新建`teek.sh`如下对内容进行抓取：

```sh
docker run -t --rm \
  --network=host \
  -e MEILISEARCH_HOST_URL='http://localhost:7700' \
  -e MEILISEARCH_API_KEY='第一步自定义的Master Key' \
  -v /tmp/scraper/config.json:/docs-scraper/config.json \
  getmeili/docs-scraper pipenv run ./docs_scraper config.json
```

将`config.json`与`teek.sh`放到`/tmp/scraper`目录下，然后通过如下命令运行爬虫对内容进行抓取：

```sh
sh teek.sh
```

{{< alert type="info" >}}

如果脚本跑完发现最后匹配到了 0 条，可能是上边 config.json 中元素选择的问题，可以到自己博客中，点击检查来查看元素的正确名称。

{{</alert >}}

## _2、代码配置

### _2.1、编写Meilisearch.vue

以下是部分核心代码，完整代码请前往[github](https://github.com/liyao52033/vitepress-teek/blob/docs/docs/.vitepress/theme/components/Meilisearch.vue)

```vue
<template>
    <div>
        <!-- 极简搜索触发 -->
        <button @click="toggleSearch">搜索</button>

        <!-- 核心搜索区域 -->
        <div v-if="isSearchOpen">
            <input 
                v-model="searchQuery" 
                type="search" 
                @input="handleInput"
                @keydown.enter="goToHit"
                autofocus
            >
            
            <!-- 仅保留结果展示核心结构 -->
            <div v-for="(group, groupIdx) in groupedHits" :key="groupIdx">
                <div>{{ group.title }}</div>
                <ul>
                    <li 
                        v-for="(hit, itemIdx) in group.items" 
                        :key="itemIdx"
                        @click="goToSpecificHit(groupIdx, itemIdx)"
                    >
                        <a :href="hit.url" v-html="highlightKeyword(hit.hierarchy_lvl2, searchQuery)"></a>
                    </li>
                </ul>
            </div>
            
            <!-- 无结果提示 -->
            <div v-if="searchQuery && hits.length === 0">无搜索结果</div>
        </div>
    </div>
</template>

<script setup>
import { instantMeiliSearch } from '@meilisearch/instant-meilisearch';
import instantsearch from 'instantsearch.js';
import { hits as hitsWidget } from 'instantsearch.js/es/widgets';
import { computed, nextTick, onUnmounted, ref } from 'vue';

// 核心配置（实际使用时需替换为你的 MeiliSearch 配置）
const meiliConfig = ref({
    host: '你的MeiliSearch服务地址',
    apiKey: '你的API密钥',
    indexName: '你的索引名称'
});

// 核心状态管理
const isSearchOpen = ref(false);
const searchQuery = ref('');
const hits = ref([]);
let searchInstance = null;
let searchClient = null;

// 结果分组（核心逻辑保留）
const groupedHits = computed(() => {
    const groupMap = new Map();
    hits.value.forEach(hit => {
        const groupKey = hit.hierarchy_lvl1 || '默认分组';
        if (!groupMap.has(groupKey)) {
            groupMap.set(groupKey, { title: groupKey, items: [] });
        }
        groupMap.get(groupKey).items.push(hit);
    });
    return Array.from(groupMap.values());
});

// 切换搜索显示状态
const toggleSearch = async () => {
    isSearchOpen.value = !isSearchOpen.value;
    if (isSearchOpen.value) {
        await nextTick();
        initMeiliSearch();
    } else {
        clearSearch();
    }
};

// 初始化 MeiliSearch 核心实例
const initMeiliSearch = () => {
    // 避免重复初始化
    if (searchInstance || !meiliConfig.value.host || !meiliConfig.value.apiKey || !meiliConfig.value.indexName) return;
    
    // 创建 MeiliSearch 客户端
    searchClient = instantMeiliSearch(
        meiliConfig.value.host, 
        meiliConfig.value.apiKey
    ).searchClient;

    // 初始化 instantsearch 实例
    searchInstance = instantsearch({
        indexName: meiliConfig.value.indexName,
        searchClient,
        routing: false
    });

    // 添加核心 hits 组件
    searchInstance.addWidgets([
        hitsWidget({
            container: document.createElement('div'), // 仅为占位，无实际DOM挂载
            transformItems: items => {
                // 结果预处理核心逻辑
                const validItems = items.map(item => {
                    // 确保URL有效性
                    if (!item.url && item.anchor) {
                        item.url = new URL(`#${item.anchor}`, window.location.href).href;
                    }
                    if (!item.url) {
                        item.url = window.location.href;
                    }
                    return item;
                }).filter(item => item.url);
                
                hits.value = validItems;
                return validItems;
            },
            templates: { item: () => '' } // 禁用默认模板
        })
    ]);

    // 启动搜索实例
    searchInstance.start();
};

// 处理搜索输入
const handleInput = () => {
    if (searchInstance?.helper) {
        if (searchQuery.value) {
            // 执行搜索查询
            searchInstance.helper.setQuery(searchQuery.value).search();
        } else {
            clearSearch();
        }
    }
};

// 清空搜索
const clearSearch = () => {
    searchQuery.value = '';
    hits.value = [];
};

// 关键词高亮核心逻辑
const highlightKeyword = (text, keyword) => {
    if (!text || !keyword) return text;
    const escapedKeyword = keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    return text.replace(
        new RegExp(`(${escapedKeyword})`, 'gi'),
        '<span class="highlight">$1</span>'
    );
};

// 跳转至选中结果
const goToHit = () => {
    if (groupedHits.value.length > 0 && groupedHits.value[0].items.length > 0) {
        const firstHit = groupedHits.value[0].items[0];
        window.location.href = firstHit.url;
        closeSearch();
    }
};

// 跳转至指定结果
const goToSpecificHit = (groupIdx, itemIdx) => {
    const hit = groupedHits.value[groupIdx]?.items[itemIdx];
    if (hit?.url) {
        window.location.href = hit.url;
        closeSearch();
    }
};

// 关闭搜索
const closeSearch = () => {
    isSearchOpen.value = false;
    clearSearch();
};

// 组件卸载时销毁实例（核心清理逻辑）
onUnmounted(() => {
    if (searchInstance) {
        searchInstance.destroy();
        searchInstance = null;
    }
});
</script>
```

### _2.2、config.ts配置

去掉vp自带的搜索`themeConfig.search`，进行如下配置

```ts
export default defineConfig({ 
  ...
  themeConfig: ({
    ...
      //@ts-ignore
        meilisearch: {
            host: 'http://localhost:5173/', // 服务地址（自建或云服务）
            apiKey: secureInfo.searchKey, // 搜索密钥（非管理员密钥）
            indexName: 'teek', // 索引名称
            placeholder: '搜索文档...' // 搜索框提示文字
        },
       
    ...
   })
  ...
})
```

### _2.3、注册组件

插入`nav-bar-content-before`插槽

```vue
<template>
  <template #nav-bar-content-before>
  	<Meilisearch />
  </template>
</template>

<script setup>
  import Meilisearch from "./components/Meilisearch.vue"; //修改为你的文件路径
</script>
```

注册好后启动项目，开始使用

## _3. 索引自动化

当我们有新的文章发布时，应该重新运行抓取文章建立索引的命令，如果你的博客是通过 Github Action 进行发布的，那么官方还提供了通过 Action 自动抓取的方案。

首先在项目根目录下新建`.github/workflows/crawler.yml`文件，内容如下：

```yaml
name: Auto Crawler

on:
  push:
    branches: [ main ]  # 当推送到main分支时触发

jobs:
  crawler:
    runs-on: ubuntu-latest
    steps:
      - name: 运行meilisearch
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.TENCENT_CLOUD_IP }} 
          username: ${{ secrets.TENCENT_CLOUD_NAME }} 
          password: ${{ secrets.TENCENT_CLOUD_PASSWORD }} 
          script:  cd /tmp/scraper && sh teek.sh
```

如上内容需要依赖以下配置信息：

- host：云服务器IP

-  username：云服务器登录用户名，一般为root

- password：云服务器登录密码

  以上三个配置需到对应的github仓库填写secret

  ![202309242306643](https://img.xiaoying.org.cn/img/20250906181132189.png)

- script：登录之后执行的指令，此处就是重新爬取内容

如上内容准备完毕之后，当我们提交了新的代码，部署上去之后，就会自动运行抓取内容

